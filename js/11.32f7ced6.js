(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{1145:function(e,t,l){"use strict";function n(e){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.MDXContent=f;var a,s=l(1),c=(a=s)&&a.__esModule?a:{default:a},r=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==n(e)&&"function"!=typeof e)return{default:e};var t=u();if(t&&t.has(e))return t.get(e);var l={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var c=a?Object.getOwnPropertyDescriptor(e,s):null;c&&(c.get||c.set)?Object.defineProperty(l,s,c):l[s]=e[s]}l.default=e,t&&t.set(e,l);return l}(l(443));function u(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return u=function(){return e},e}function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var l=arguments[t];for(var n in l)Object.prototype.hasOwnProperty.call(l,n)&&(e[n]=l[n])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var l,n,a=function(e,t){if(null==e)return{};var l,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)l=s[n],t.indexOf(l)>=0||(a[l]=e[l]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)l=s[n],t.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(a[l]=e[l])}return a}var d={},m=r.Content;function f(e){var t=e.components,n=o(e,["components"]);return c.default.createElement(m,i({},d,n,{components:t}),c.default.createElement("p",null,"  今天尝试一下手写一个",c.default.createElement("code",{className:"inline"},"Promise"),"，我们不实现错误状态，只实现成功状态，也就是",c.default.createElement("code",{className:"inline"},"new Promise(fn).then(fn)"),"，看看需要几行代码能实现该功能。"),c.default.createElement("h2",null,c.default.createElement(r.AnchorLinkEnhance,{to:"构造函数"},"#"),c.default.createElement("span",null,"构造函数")),c.default.createElement("p",null,"可以看出",c.default.createElement("code",{className:"inline"},"Promise"),"是一个构造函数，通过",c.default.createElement("code",{className:"inline"},"new"),"实例化，接收一个回调函数作为参数。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"function Promise(callback) {}\n")),c.default.createElement("p",null,c.default.createElement("code",{className:"inline"},"Promise"),"有2个属性",c.default.createElement("code",{className:"inline"},"state"),"和",c.default.createElement("code",{className:"inline"},"result"),"分别记录状态和结果。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"function Promise(callback) {\n  this.status = 'pending';\n  this.result = undefined;\n}\n")),c.default.createElement("p",null,"构造函数实例化时接收一个回调函数，该回调函数会被立即调用，调用时需传入函数",c.default.createElement("code",{className:"inline"},"resolve"),"，用于更新",c.default.createElement("code",{className:"inline"},"state"),"和",c.default.createElement("code",{className:"inline"},"result"),"。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"function Promise(callback) {\n  this.status = 'pending';\n  this.result = undefined;\n  const resolve = (e) => {\n    this.status = 'fulfilled';\n    this.result = e;  \n  }\n  callback(resolve);\n}\n")),c.default.createElement("h2",null,c.default.createElement(r.AnchorLinkEnhance,{to:"then"},"#"),c.default.createElement("span",null,"then")),c.default.createElement("p",null,"实例对象包含一个",c.default.createElement("code",{className:"inline"},"then"),"方法，接收一个回调函数",c.default.createElement("code",{className:"inline"},"onFulfilled"),"，该回调函数会在",c.default.createElement("code",{className:"inline"},"resolve"),"执行时被调用，并将",c.default.createElement("code",{className:"inline"},"result"),"作为参数传入。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"Promise.prototype.then = function(onFulfilled) {\n  onFulfilled(this.result);\n}\n")),c.default.createElement("p",null,"好了，现在我们来测试一下代码。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"new Promise((resolve) => {\n  resolve(1);\n}).then((e) => {\n  console.log(e);\n});\n")),c.default.createElement("p",null,"代码成功打印出了",c.default.createElement("code",{className:"inline"},"1"),"，貌似没有问题，可如果",c.default.createElement("code",{className:"inline"},"resolve"),"是延迟执行呢？"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(1);\n  }, 100);\n}).then((e) => {\n  console.log(e);\n});\n")),c.default.createElement("p",null,"打印出来的却是",c.default.createElement("code",{className:"inline"},"undefined"),"，所以需要改造一下代码，将",c.default.createElement("code",{className:"inline"},"onFulfilled"),"放入回调中，",c.default.createElement("code",{className:"inline"},"resolve"),"调用后再执行这个回调。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"function Promise(callback) {\n  this.status = 'pending';\n  this.result = undefined;\n  this._onFulfilled = () => {};\n  const resolve = (e) => {\n    this.status = 'fulfilled';\n    this.result = e;\n    this._onFulfilled();\n  }\n  callback(resolve);\n}\nPromise.prototype.then = function(onFulfilled) {\n  this._onFulfilled = () => {\n    onFulfilled(this.result);\n  }\n}\n")),c.default.createElement("p",null,"再执行刚才代码打印出了",c.default.createElement("code",{className:"inline"},"1"),"，不过如果将",c.default.createElement("code",{className:"inline"},"setTimeout"),"去掉，又发现了一个问题，",c.default.createElement("code",{className:"inline"},"onFulfilled"),"不执行了，这是因为",c.default.createElement("code",{className:"inline"},"resolve"),"是立即执行的，",c.default.createElement("code",{className:"inline"},"_onFulfilled"),"还没有创建，所以需要在",c.default.createElement("code",{className:"inline"},"resolve"),"中加一个延迟。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"function Promise(callback) {\n  this.status = 'pending';\n  this.result = undefined;\n  this._onFulfilled = () => {};\n  const resolve = (e) => {\n    queueMicrotask(() => {\n      this.status = 'fulfilled';\n      this.result = e;\n      this._onFulfilled();\n    });\n  }\n  callback(resolve);\n}\n")),c.default.createElement("p",null,"因为",c.default.createElement("code",{className:"inline"},"Promise"),"属于",c.default.createElement("code",{className:"inline"},"微任务"),"，相比较",c.default.createElement("code",{className:"inline"},"setTimeout"),"，使用",c.default.createElement("code",{className:"inline"},"queueMicrotask"),"会更好，OK，这样不管延迟还是不延迟，都可以打印出",c.default.createElement("code",{className:"inline"},"1"),"。"),c.default.createElement("h3",null,c.default.createElement(r.AnchorLinkEnhance,{to:"链式调用"},"#"),c.default.createElement("span",null,"链式调用")),c.default.createElement("p",null,"我们知道",c.default.createElement("code",{className:"inline"},"Promise"),"都是支持链式调用的，类似这样",c.default.createElement("code",{className:"inline"},"then(fn).then(fn)..."),"，并且后面",c.default.createElement("code",{className:"inline"},"onFulfilled"),"接收的参数是前面的返回值，只要在",c.default.createElement("code",{className:"inline"},"then"),"中返回一个",c.default.createElement("code",{className:"inline"},"Promise"),"实例就可以实现。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"Promise.prototype.then = function(onFulfilled) {\n  return new Promise((resolve) => {\n    this._onFulfilled = () => {\n      resolve(onFulfilled(this.result));\n    }\n  });\n}\n")),c.default.createElement("p",null,"这样基本的",c.default.createElement("code",{className:"inline"},"Promise"),"功能就已经实现了，一共20行代码。"),c.default.createElement("pre",null,c.default.createElement("code",{className:"language-js"},"function Promise(callback) {\n  this.status = 'pending';\n  this.result = undefined;\n  this._onFulfilled = () => {};\n  const resolve = (e) => {\n    queueMicrotask(() => {\n      this.status = 'fulfilled';\n      this.result = e;\n      this._onFulfilled();\n    });\n  }\n  callback(resolve);\n}\nPromise.prototype.then = function(onFulfilled) {\n  return new Promise((resolve) => {\n    this._onFulfilled = () => {\n      resolve(onFulfilled(this.result));\n    }\n  });\n}\n")),c.default.createElement("h2",null,c.default.createElement(r.AnchorLinkEnhance,{to:"总结"},"#"),c.default.createElement("span",null,"总结")),c.default.createElement("p",null,"这里只是简单实现了",c.default.createElement("code",{className:"inline"},"Promise"),"的基本功能，其中",c.default.createElement("code",{className:"inline"},"resolve"),"内部需要使用微任务进行延迟执行，",c.default.createElement("code",{className:"inline"},"then"),"方法需要返回一个",c.default.createElement("code",{className:"inline"},"Promise"),"实例。",c.default.createElement("code",{className:"inline"},"Promise"),"本身还有好多特性，比如",c.default.createElement("code",{className:"inline"},"catch"),"、",c.default.createElement("code",{className:"inline"},"finally"),"、",c.default.createElement("code",{className:"inline"},"Promise.all"),"等，后续会实现一个完整版的。"),c.default.createElement("section",null,c.default.createElement(r.Component,{render:function(e,t){var n=t.location;if(!1!==t.store.state.setting.valine){window.AV=l(1135);var a=l(1136),s={appId:"MD2yAhzrq1utFR2VxH2oU1YF-gzGzoHsz",appKey:"qbn6SClpr7xzhzHdtWNnNSYi"};s.el=e,s.path=n.pathname,new a(s)}}})))}f.isMDXComponent=!0;var p={state:{showCode:!1,setting:{title:"实现Promise需要几行代码"},headings:[{text:"构造函数",depth:2,level:1},{text:"then",depth:2,level:1},{text:"链式调用",depth:3,level:2},{text:"总结",depth:2,level:1}],showSidebar:!0,showPageSidebar:!0,sidebarMenus:[{text:"构造函数",depth:2,level:1},{text:"then",depth:2,level:1},{text:"链式调用",depth:3,level:2},{text:"总结",depth:2,level:1}],pageSidebarMenus:[],utime:1677827173746.1914},render:function(){return c.default.createElement(f,{pageExtra:{platform:"Github",path:"https://github.com/yinjiazeng/yinjiazeng.github.io/tree/master/docs",format:"yyyy/MM/dd hh:mm:ss"}})}};p.state.title="实现Promise需要几行代码",t.default=p}}]);